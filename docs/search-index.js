var searchIndex = new Map(JSON.parse('[\
["fasten",{"doc":"Perform random operations on fastq files, using unix …","t":"HHHCHQHCCFNNNNNNNNNNNKFMNNNNNNNMNONMNMNMNMNOMNOMNOONMNMNNNN","n":["eexit","fasten_base_options","fasten_base_options_matches","io","logmsg","print","reverse_complement","fastq","seq","FastqReader","borrow","borrow_mut","from","into","into_iter","new","new_careful","next","try_from","try_into","type_id","Cleanable","Seq","blank","blank","borrow","borrow_mut","clone","clone_into","fmt","from","from_string","from_string","id","into","is_blank","is_blank","is_high_quality","is_high_quality","lower_ambiguity_q","lower_ambiguity_q","new","new","pairid","print","print","qual","sanitize_id","sanitize_id","seq","thresholds","to_owned","to_string","to_string","trim","trim","try_from","try_into","type_id"],"q":[[0,"fasten"],[7,"fasten::io"],[9,"fasten::io::fastq"],[21,"fasten::io::seq"],[59,"getopts"],[60,"getopts"],[61,"alloc::string"],[62,"std::io"],[63,"core::option"],[64,"core::result"],[65,"core::any"],[66,"core::fmt"],[67,"core::fmt"]],"d":["Propagate an error by printing invalid read(s)","a function that reads an options object and adds fasten …","a function that processes the options on the command line …","input/output methods","Print a formatted message to stderr ","Rewrite print!() so that it doesn’t panic on broken pipe.","Reverse complement a DNA sequence. Take into account …","","","A FastQ reader","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","There are two flavors of next: either read  quickly or …","","","","A sequence that can be cleaned","A sequence struct that contains the ID, sequence, and …","Make a blank sequence object.","Make a blank sequence object.","","","","","","Returns the argument unchanged.","Make a seq object from a String.","Create a sequence object from a string. TODO make it more …","","Calls <code>U::from(self)</code>.","Determine if it is a blank sequence.","Determine if it is a blank sequence.","Reports bool whether the read passes thresholds.","Reports bool whether the read passes thresholds.","lower any low quality base to a zero and “N”","Alter any ambiguity site with a quality=0","new sequence object","Make a new cleanable sequence object","","Print the result of to_string()","","","sanitize an identifier string","Read an identifier and return a cleaned version, e.g., …","","","","Make a String object","","Trim sequences based on quality","Trim the ends of reads with low quality","","",""],"i":[0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,0,0,15,9,9,9,9,9,9,9,15,9,9,9,15,9,15,9,15,9,15,9,9,15,9,9,15,9,9,9,9,15,9,15,9,9,9,9],"f":"{{}b}{{}d}{{fd}h}`{cb{{j{f}}}}`{fl}```{ce{}{}}0{cc{}}11{c{{n{c}}}A`}0{{{n{c}}}{{Ad{Ab}}}A`}{c{{Af{e}}}{}{}}0{cAh{}}``{{}Ab}066{AbAb}{{ce}b{}{}}{{AbAj}Al}8{lAb}0`:{AnB`}{AbB`}10{Anb}{Abb}{{lll}Ab}0`21`{ll}0``{ce{}{}}{Anl}{Abl}65??>","c":[],"p":[[1,"unit"],[5,"Options",59],[1,"str"],[5,"Matches",59],[10,"AsRef",60],[5,"String",61],[5,"FastqReader",9],[10,"Read",62],[5,"Seq",21],[6,"Option",63],[6,"Result",64],[5,"TypeId",65],[5,"Formatter",66],[8,"Result",66],[10,"Cleanable",21],[1,"bool"]],"b":[]}],\
["fasten_clean",{"doc":"Trim and filter reads","t":"HHH","n":["avg_quality","main","trim"],"q":[[0,"fasten_clean"],[3,"alloc::string"]],"d":["Determine average quality of a qual cigar string, e.g., …","","Trim the ends of reads with low quality"],"i":[0,0,0],"f":"{bd}{{}f}{{bbh}{{j{bb}}}}","c":[],"p":[[5,"String",3],[1,"f32"],[1,"unit"],[1,"u8"],[1,"tuple"]],"b":[]}],\
["fasten_combine",{"doc":"Collapse identical reads into single reads, recalculating …","t":"SSHH","n":["READ_SEPARATOR","TEN","combine_error_vectors","main"],"q":[[0,"fasten_combine"],[4,"alloc::vec"]],"d":["Glues together paired end reads internally and is a …","need this constant because the compiler had a problem with …","Combines vectors of error probabilities such that the rate …",""],"i":[0,0,0,0],"f":"``{{{d{b}}{d{b}}}{{d{b}}}}{{}f}","c":[],"p":[[1,"f32"],[5,"Vec",4],[1,"unit"]],"b":[]}],\
["fasten_convert",{"doc":"Convert between different sequence formats","t":"FNNNNNNNNNOONHNOOHHHOONNNNHHH","n":["FastenSeq","as_fasta","as_fastq","as_sam","borrow","borrow_mut","clone","clone_into","fmt","from","id1","id2","into","main","new","qual1","qual2","read_fasta","read_fastq","read_sam","seq1","seq2","to_owned","try_from","try_into","type_id","write_fasta","write_fastq","write_sam"],"q":[[0,"fasten_convert"],[29,"alloc::string"],[30,"core::fmt"],[31,"core::fmt"],[32,"core::result"],[33,"core::any"],[34,"std::sync::mpsc"]],"d":["Struct that can handle paired end reads","Return a formatted string as a fasta entry","Return a formatted string as a fastq entry","Return a formatted string as a sam entry","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","a blank new object is a set of blank strings for each value","","","Read fasta from stdin and transmit it to a channel","Read fastq from stdin and transmit it to a channel","Read sam from stdin and transmit it to a channel","","","","","","","Read from a channel and print as fasta","Read from a channel and print as fastq","Read from a channel and print as sam"],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0],"f":"`{bd}00{ce{}{}}0{bb}{{ce}f{}{}}{{bh}j}{cc{}}``4{{}f}{{}b}``{{{l{b}}n}f}00``7{c{{A`{e}}}{}{}}0{cAb{}}{{{Ad{b}}}f}00","c":[],"p":[[5,"FastenSeq",0],[5,"String",29],[1,"unit"],[5,"Formatter",30],[8,"Result",30],[5,"Sender",31],[1,"bool"],[6,"Result",32],[5,"TypeId",33],[5,"Receiver",31]],"b":[]}],\
["fasten_inspect",{"doc":"Marks up your reads with useful information like read …","t":"HH","n":["main","validate_reads"],"q":[[0,"fasten_inspect"],[2,"regex::regex::string"]],"d":["","marks up reads from stdin"],"i":[0,0],"f":"{{}b}{{dff}b}","c":[],"p":[[1,"unit"],[1,"u8"],[5,"Regex",2]],"b":[]}],\
["fasten_kmer",{"doc":"Counts kmers. Each line is a kmer with two columns …","t":"SHHHHH","n":["READ_SEPARATOR","count_kmers","kmers_in_str","main","revcomp","switch_base"],"q":[[0,"fasten_kmer"],[6,"std::io::stdio"],[7,"alloc::string"],[8,"std::collections::hash::map"]],"d":["Glues together paired end reads internally and is a …","Read fastq from stdin and count kmers","Read a str of nucleotides and count kmers. If …","","reverse-complement a dna sequence","Complementary nucleotide for ACTGUN, case insensitive"],"i":[0,0,0,0,0,0],"f":"`{{bdfff}h}{{jdf}{{A`{ln}}}}{{}h}{jl}{AbAb}","c":[],"p":[[5,"Stdin",6],[1,"usize"],[1,"bool"],[1,"unit"],[1,"str"],[5,"String",7],[1,"u32"],[5,"HashMap",8],[1,"char"]],"b":[]}],\
["fasten_metrics",{"doc":"Gives read metrics on a read set. Values are given in a …","t":"HHH","n":["average_quality","main","standard_deviation"],"q":[[0,"fasten_metrics"],[3,"alloc::vec"]],"d":["given a cigar line for quality, return its average","","Local implementation of standard deviation"],"i":[0,0,0],"f":"{bd}{{}f}{{{h{d}}}d}","c":[],"p":[[1,"str"],[1,"f32"],[1,"unit"],[5,"Vec",3]],"b":[]}],\
["fasten_mutate",{"doc":"Mutates reads. There is no mutation model; only randomness.","t":"HH","n":["main","mutate"],"q":[[0,"fasten_mutate"],[2,"alloc::vec"],[3,"alloc::string"]],"d":["","Mutate a str of a sequence of nucleotides using the …"],"i":[0,0],"f":"{{}b}{{d{h{f}}jl}n}","c":[],"p":[[1,"unit"],[1,"str"],[1,"char"],[5,"Vec",2],[1,"u8"],[1,"bool"],[5,"String",3]],"b":[]}],\
["fasten_normalize",{"doc":"Normalizes kmer depth by removing some reads from high …","t":"SHHH","n":["READ_SEPARATOR","main","normalize_coverage","print_reads"],"q":[[0,"fasten_normalize"],[4,"std::io::stdio"],[5,"alloc::vec"]],"d":["Glues together paired end reads internally and is a …","","Normalize the coverage to a certain target and print as a …","Print the reads in fastq format when given in a single …"],"i":[0,0,0,0],"f":"`{{}b}{{dfh}b}{{{l{j}}}b}","c":[],"p":[[1,"unit"],[5,"Stdin",4],[1,"u32"],[1,"bool"],[1,"str"],[5,"Vec",5]],"b":[]}],\
["fasten_pe",{"doc":"Determine paired-end-ness in an interleaved file. Exit …","t":"HHH","n":["is_paired_end_miseq","is_paired_end_slash12","main"],"q":[[0,"fasten_pe"],[3,"alloc::string"],[4,"alloc::vec"]],"d":["Detect whether the vector of IDs represent paired-endedness","Detect whether the vector of IDs represent paired-endedness",""],"i":[0,0,0],"f":"{{{d{b}}{d{b}}}f}0{{}h}","c":[],"p":[[5,"String",3],[5,"Vec",4],[1,"u8"],[1,"unit"]],"b":[]}],\
["fasten_progress",{"doc":"Prints a progress meter for number of fastq entries to …","t":"H","n":["main"],"q":[[0,"fasten_progress"]],"d":[""],"i":[0],"f":"{{}b}","c":[],"p":[[1,"unit"]],"b":[]}],\
["fasten_quality_filter",{"doc":"Transforms any low-quality base to ‘N’","t":"H","n":["main"],"q":[[0,"fasten_quality_filter"]],"d":[""],"i":[0],"f":"{{}b}","c":[],"p":[[1,"unit"]],"b":[]}],\
["fasten_randomize",{"doc":"Create random reads from stdin.","t":"HH","n":["main","print_reads_from_stdin"],"q":[[0,"fasten_randomize"]],"d":["","Read fastq from stdin, add the reads to a vector, then …"],"i":[0,0],"f":"{{}b}{db}","c":[],"p":[[1,"unit"],[1,"u32"]],"b":[]}],\
["fasten_regex",{"doc":"Filter reads based on a regular expression.","t":"H","n":["main"],"q":[[0,"fasten_regex"]],"d":[""],"i":[0],"f":"{{}b}","c":[],"p":[[1,"unit"]],"b":[]}],\
["fasten_repair",{"doc":"Repairs reads from fasten_inspect output","t":"HHH","n":["main","repair_one_read","repair_reads"],"q":[[0,"fasten_repair"],[3,"alloc::string"]],"d":["","Repair exactly one read","Repairs reads depending on the deflines by calling …"],"i":[0,0,0],"f":"{{}b}{{ddddfhjf}{{l{dfd}}}}{{fhjfn}b}","c":[],"p":[[1,"unit"],[5,"String",3],[1,"bool"],[1,"usize"],[1,"f32"],[1,"tuple"],[1,"str"]],"b":[]}],\
["fasten_replace",{"doc":"Streaming editor for fastq data using a find/replace.","t":"H","n":["main"],"q":[[0,"fasten_replace"]],"d":[""],"i":[0],"f":"{{}b}","c":[],"p":[[1,"unit"]],"b":[]}],\
["fasten_sample",{"doc":"downsample your reads","t":"HH","n":["main","rand_32"],"q":[[0,"fasten_sample"],[2,"alloc::vec"]],"d":["","Generate a set of random floats"],"i":[0,0],"f":"{{}b}{{}{{f{d}}}}","c":[],"p":[[1,"unit"],[1,"f32"],[5,"Vec",2]],"b":[]}],\
["fasten_shuffle",{"doc":"Interleaves reads from either stdin or file parameters.","t":"HHHH","n":["deshuffle","main","read_seqs","shuffle"],"q":[[0,"fasten_shuffle"],[4,"getopts"],[5,"alloc::string"],[6,"fasten::io::seq"],[7,"alloc::vec"]],"d":["Read from stdin and deshuffle reads into files","","Read fastq entries from a filename","Read fastq from stdin and interleave"],"i":[0,0,0,0],"f":"{bd}{{}d}{f{{j{h}}}}2","c":[],"p":[[5,"Matches",4],[1,"unit"],[5,"String",5],[5,"Seq",6],[5,"Vec",7]],"b":[]}],\
["fasten_sort",{"doc":"Sort a fastq file. If the reads are paired end, then the …","t":"FNNNNNNOONHOOOOOHNNNN","n":["Seq","borrow","borrow_mut","clone","clone_into","fmt","from","id1","id2","into","main","pe","qual1","qual2","seq1","seq2","sort_entries","to_owned","try_from","try_into","type_id"],"q":[[0,"fasten_sort"],[21,"core::fmt"],[22,"core::fmt"],[23,"core::result"],[24,"core::any"]],"d":["A sequence struct that is paired-end aware","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","","","","Sort fastq entries in a vector","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1],"f":"`{ce{}{}}0{bb}{{ce}d{}{}}{{bf}h}{cc{}}``4{{}d}`````{{{j{b}}ln}{{j{b}}}}6{c{{A`{e}}}{}{}}0{cAb{}}","c":[],"p":[[5,"Seq",0],[1,"unit"],[5,"Formatter",21],[8,"Result",21],[5,"Vec",22],[1,"str"],[1,"bool"],[6,"Result",23],[5,"TypeId",24]],"b":[]}],\
["fasten_straighten",{"doc":"Convert a fastq file to a standard 4-lines-per-entry format","t":"H","n":["main"],"q":[[0,"fasten_straighten"]],"d":[""],"i":[0],"f":"{{}b}","c":[],"p":[[1,"unit"]],"b":[]}],\
["fasten_trim",{"doc":"Trims reads using 0-based coordinates","t":"HHH","n":["main","read_fasta","trim_worker"],"q":[[0,"fasten_trim"],[3,"alloc::string"],[4,"std::collections::hash::map"],[5,"fasten::io::seq"],[6,"alloc::vec"]],"d":["","Read a fasta file and return a HashMap of the sequences","Trim a set of fastq entries and send it to a channel"],"i":[0,0,0],"f":"{{}b}{d{{h{ff}}}}{{jll{n{f}}}f}","c":[],"p":[[1,"unit"],[1,"str"],[5,"String",3],[5,"HashMap",4],[5,"Seq",5],[1,"usize"],[5,"Vec",6]],"b":[]}],\
["fasten_validate",{"doc":"Validates your reads and makes you feel good about …","t":"H","n":["main"],"q":[[0,"fasten_validate"]],"d":[""],"i":[0],"f":"{{}b}","c":[],"p":[[1,"unit"]],"b":[]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
