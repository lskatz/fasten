initSidebarItems({"fn":[["broadcast_fut_queue","Futures variant of broadcast_queue - datastructures implement Sink + Stream at a minor (~30 ns) performance cost to BlockingWait"],["broadcast_queue","Creates a (`BroadcastSender`, `BroadcastReceiver`) pair with a capacity that’s the next power of two >= the given capacity"],["broadcast_queue_with","Creates a (`BroadcastSender`, `BroadcastReceiver`) pair with a capacity that’s the next power of two >= the given capacity and the specified wait strategy"],["mpmc_fut_queue","Futures variant of `mpmc_queue` - datastructures implement Sink + Stream at a minor (~30 ns) performance cost to `BlockingWait`"],["mpmc_queue","Creates a (`MPMCSender`, `MPMCReceiver`) pair with a capacity that’s the next power of two >= the given capacity"],["mpmc_queue_with",""]],"mod":[["wait","This module contains the waiting strategies used by the queue when there is no data left. Users should not find themselves directly accessing these except for construction unless a custom Wait is being written."]],"struct":[["BroadcastFutReceiver","This is the futures-compatible version of `BroadcastReceiver` It implements `Stream`"],["BroadcastFutSender","This is the futures-compatible version of `BroadcastSender` It implements Sink"],["BroadcastFutUniReceiver","This is the futures-compatible version of `BroadcastUniReceiver` It implements `Stream` and behaves like the iterator would. To use a different function must transform itself into a different `BroadcastFutUniRecveiver` use `transform_operation`"],["BroadcastReceiver","This class is the receiving half of the broadcast `MultiQueue`. Within each stream, it supports both single and multi consumer modes with competitive performance in each case. It supports blocking and nonblocking read modes as well as being the conduit for adding new streams."],["BroadcastSender","This class is the sending half of the broadcasting `MultiQueue`. It supports both single and multi consumer modes with competitive performance in each case. It only supports nonblocking writes (the futures sender being an exception) as well as being the conduit for adding new writers."],["BroadcastUniReceiver","This class is similar to the receiver, except it ensures that there is only one consumer for the stream it owns. This means that one can safely view the data in-place with the recv_view method family and avoid the cost of copying it. If there’s only one receiver on a stream, it can be converted into a `BroadcastUniInnerRecv`"],["MPMCFutReceiver","This is the futures-compatible version of `MPMCReceiver` It implements Stream"],["MPMCFutSender","This is the futures-compatible version of `MPMCSender` It implements Sink"],["MPMCFutUniReceiver","This is the futures-compatible version of `MPMCUniReceiver` It implements `Stream` and behaves like the iterator would. To use a different function must transform itself into a different UniRecveiver use `transform_operation`"],["MPMCReceiver","This is the receiving end of a standard mpmc view of the queue It functions similarly to the `BroadcastReceiver` execpt there is only ever one stream. As a result, the type doesn’t need to be clone"],["MPMCSender","This class is the sending half of the mpmc `MultiQueue`. It supports both single and multi consumer modes with competitive performance in each case. It only supports nonblocking writes (the futures sender being an exception) as well as being the conduit for adding new writers."],["MPMCUniReceiver","This is the receiving end of a standard mpmc view of the queue for when it’s statically know that there is only one receiver. It functions similarly to the `BroadcastUniReceiver` execpt there is only ever one stream. As a result, the type doesn’t need to be clone or sync"]]});