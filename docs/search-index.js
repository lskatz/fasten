var searchIndex = JSON.parse('{\
"fasten":{"doc":"Perform random operations on fastq files, using unix …","t":"FFFAFOAADLLLLLLLLLLLIDKLLLLLLLKLMLKLKLKLKLMKLMKLMMLKLKLLLL","n":["eexit","fasten_base_options","fasten_base_options_matches","io","logmsg","print","fastq","seq","FastqReader","borrow","borrow_mut","from","into","into_iter","new","new_careful","next","try_from","try_into","type_id","Cleanable","Seq","blank","blank","borrow","borrow_mut","clone","clone_into","fmt","from","from_string","from_string","id","into","is_blank","is_blank","is_high_quality","is_high_quality","lower_ambiguity_q","lower_ambiguity_q","new","new","pairid","print","print","qual","sanitize_id","sanitize_id","seq","thresholds","to_owned","to_string","to_string","trim","trim","try_from","try_into","type_id"],"q":[[0,"fasten"],[6,"fasten::io"],[8,"fasten::io::fastq"],[20,"fasten::io::seq"]],"d":["Propagate an error by printing invalid read(s)","a function that reads an options object and adds fasten …","a function that processes the options on the command line …","input/output methods","Print a formatted message to stderr ","Rewrite print!() so that it doesn’t panic on broken pipe.","","","A FastQ reader","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","","","There are two flavors of next: either read  quickly or …","","","","A sequence that can be cleaned","A sequence struct that contains the ID, sequence, and …","Make a blank sequence object.","Make a blank sequence object.","","","","","","Returns the argument unchanged.","Make a seq object from a String.","Create a sequence object from a string. TODO make it more …","","Calls <code>U::from(self)</code>.","Determine if it is a blank sequence.","Determine if it is a blank sequence.","Reports bool whether the read passes thresholds.","Reports bool whether the read passes thresholds.","lower any low quality base to a zero and “N”","Alter any ambiguity site with a quality=0","new sequence object","Make a new cleanable sequence object","","Print the result of to_string()","","","sanitize an identifier string","Read an identifier and return a cleaned version, e.g., …","","","","Make a String object","","Trim sequences based on quality","Trim the ends of reads with low quality","","",""],"i":[0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,0,0,15,7,7,7,7,7,7,7,15,7,7,7,15,7,15,7,15,7,15,7,7,15,7,7,15,7,7,7,7,15,7,15,7,7,7,7],"f":[[[]],[[],1],[[2,1],3],0,[[[4,[2]]]],0,0,0,0,[[]],[[]],[[]],[[]],[[]],[5,[[6,[5]]]],[5,[[6,[5]]]],[[[6,[5]]],[[8,[7]]]],[[],9],[[],9],[[],10],0,0,[[],7],[[],7],[[]],[[]],[7,7],[[]],[[7,11],12],[[]],[13,7],[13,7],0,[[]],[[],14],[7,14],[[],14],[7,14],[[]],[7],[[13,13,13],7],[[13,13,13],7],0,[[]],[7],0,[13,13],[13,13],0,0,[[]],[[],13],[7,13],[[]],[7],[[],9],[[],9],[[],10]],"c":[],"p":[[3,"Options"],[15,"str"],[3,"Matches"],[8,"AsRef"],[8,"Read"],[3,"FastqReader"],[3,"Seq"],[4,"Option"],[4,"Result"],[3,"TypeId"],[3,"Formatter"],[6,"Result"],[3,"String"],[15,"bool"],[8,"Cleanable"]]},\
"fasten_clean":{"doc":"Trim and filter reads","t":"FFF","n":["avg_quality","main","trim"],"q":[[0,"fasten_clean"]],"d":["Determine average quality of a qual cigar string, e.g., …","","Trim the ends of reads with low quality"],"i":[0,0,0],"f":[[1,2],[[]],[[1,1,3]]],"c":[],"p":[[3,"String"],[15,"f32"],[15,"u8"]]},\
"fasten_combine":{"doc":"Collapse identical reads into single reads, recalculating …","t":"RRFF","n":["READ_SEPARATOR","TEN","combine_error_vectors","main"],"q":[[0,"fasten_combine"]],"d":["Glues together paired end reads internally and is a …","need this constant because the compiler had a problem with …","Combines vectors of error probabilities such that the rate …",""],"i":[0,0,0,0],"f":[0,0,[[[2,[1]],[2,[1]]],[[2,[1]]]],[[]]],"c":[],"p":[[15,"f32"],[3,"Vec"]]},\
"fasten_convert":{"doc":"Convert between different sequence formats","t":"DLLLLLLLLLMMLFLMMFFFMMLLLLFFF","n":["FastenSeq","as_fasta","as_fastq","as_sam","borrow","borrow_mut","clone","clone_into","fmt","from","id1","id2","into","main","new","qual1","qual2","read_fasta","read_fastq","read_sam","seq1","seq2","to_owned","try_from","try_into","type_id","write_fasta","write_fastq","write_sam"],"q":[[0,"fasten_convert"]],"d":["Struct that can handle paired end reads","Return a formatted string as a fasta entry","Return a formatted string as a fastq entry","Return a formatted string as a sam entry","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","a blank new object is a set of blank strings for each value","","","Read fasta from stdin and transmit it to a channel","Read fastq from stdin and transmit it to a channel","Read sam from stdin and transmit it to a channel","","","","","","","Read from a channel and print as fasta","Read from a channel and print as fastq","Read from a channel and print as sam"],"i":[0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0],"f":[0,[1,2],[1,2],[1,2],[[]],[[]],[1,1],[[]],[[1,3],4],[[]],0,0,[[]],[[]],[[],1],0,0,[[[5,[1]],6]],[[[5,[1]],6]],[[[5,[1]],6]],0,0,[[]],[[],7],[[],7],[[],8],[[[9,[1]]]],[[[9,[1]]]],[[[9,[1]]]]],"c":[],"p":[[3,"FastenSeq"],[3,"String"],[3,"Formatter"],[6,"Result"],[3,"Sender"],[15,"bool"],[4,"Result"],[3,"TypeId"],[3,"Receiver"]]},\
"fasten_inspect":{"doc":"Marks up your reads with useful information like read …","t":"FF","n":["main","validate_reads"],"q":[[0,"fasten_inspect"]],"d":["","marks up reads from stdin"],"i":[0,0],"f":[[[]],[[1,2,2]]],"c":[],"p":[[15,"u8"],[3,"Regex"]]},\
"fasten_kmer":{"doc":"Counts kmers. Each line is a kmer with two columns …","t":"RFFFFF","n":["READ_SEPARATOR","count_kmers","kmers_in_str","main","revcomp","switch_base"],"q":[[0,"fasten_kmer"]],"d":["Glues together paired end reads internally and is a …","Read fastq from stdin and count kmers","Read a str of nucleotides and count kmers. If …","","reverse-complement a dna sequence","Complementary nucleotide for ACTGUN, case insensitive"],"i":[0,0,0,0,0,0],"f":[0,[[1,2,3,3,3]],[[4,2,3],[[7,[5,6]]]],[[]],[4,5],[8,8]],"c":[],"p":[[3,"Stdin"],[15,"usize"],[15,"bool"],[15,"str"],[3,"String"],[15,"u32"],[3,"HashMap"],[15,"char"]]},\
"fasten_metrics":{"doc":"Gives read metrics on a read set. Values are given in a …","t":"FFF","n":["average_quality","main","standard_deviation"],"q":[[0,"fasten_metrics"]],"d":["given a cigar line for quality, return its average","","Local implementation of standard deviation"],"i":[0,0,0],"f":[[1,2],[[]],[[[3,[2]]],2]],"c":[],"p":[[15,"str"],[15,"f32"],[3,"Vec"]]},\
"fasten_mutate":{"doc":"Mutates reads. There is no mutation model; only randomness.","t":"FF","n":["main","mutate"],"q":[[0,"fasten_mutate"]],"d":["","Mutate a str of a sequence of nucleotides using the …"],"i":[0,0],"f":[[[]],[[1,[3,[2]],4,5],6]],"c":[],"p":[[15,"str"],[15,"char"],[3,"Vec"],[15,"u8"],[15,"bool"],[3,"String"]]},\
"fasten_normalize":{"doc":"Normalizes kmer depth by removing some reads from high …","t":"RFFF","n":["READ_SEPARATOR","main","normalize_coverage","print_reads"],"q":[[0,"fasten_normalize"]],"d":["Glues together paired end reads internally and is a …","","Normalize the coverage to a certain target and print as a …","Print the reads in fastq format when given in a single …"],"i":[0,0,0,0],"f":[0,[[]],[[1,2,3]],[[[5,[4]]]]],"c":[],"p":[[3,"Stdin"],[15,"u32"],[15,"bool"],[15,"str"],[3,"Vec"]]},\
"fasten_pe":{"doc":"Determine paired-end-ness in an interleaved file. Exit …","t":"FFF","n":["is_paired_end_miseq","is_paired_end_slash12","main"],"q":[[0,"fasten_pe"]],"d":["Detect whether the vector of IDs represent paired-endedness","Detect whether the vector of IDs represent paired-endedness",""],"i":[0,0,0],"f":[[[[2,[1]],[2,[1]]],3],[[[2,[1]],[2,[1]]],3],[[]]],"c":[],"p":[[3,"String"],[3,"Vec"],[15,"u8"]]},\
"fasten_progress":{"doc":"Prints a progress meter for number of fastq entries to …","t":"F","n":["main"],"q":[[0,"fasten_progress"]],"d":[""],"i":[0],"f":[[[]]],"c":[],"p":[]},\
"fasten_quality_filter":{"doc":"Transforms any low-quality base to ‘N’","t":"F","n":["main"],"q":[[0,"fasten_quality_filter"]],"d":[""],"i":[0],"f":[[[]]],"c":[],"p":[]},\
"fasten_randomize":{"doc":"Create random reads from stdin.","t":"FF","n":["main","print_reads_from_stdin"],"q":[[0,"fasten_randomize"]],"d":["","Read fastq from stdin, add the reads to a vector, then …"],"i":[0,0],"f":[[[]],[1]],"c":[],"p":[[15,"u32"]]},\
"fasten_regex":{"doc":"Filter reads based on a regular expression.","t":"F","n":["main"],"q":[[0,"fasten_regex"]],"d":[""],"i":[0],"f":[[[]]],"c":[],"p":[]},\
"fasten_repair":{"doc":"Repairs reads from fasten_inspect output","t":"FFF","n":["main","repair_one_read","repair_reads"],"q":[[0,"fasten_repair"]],"d":["","Repair exactly one read","Repairs reads depending on the deflines by calling …"],"i":[0,0,0],"f":[[[]],[[1,1,1,1,2,3,4,2]],[[2,3,4,2,5]]],"c":[],"p":[[3,"String"],[15,"bool"],[15,"usize"],[15,"f32"],[15,"str"]]},\
"fasten_replace":{"doc":"Streaming editor for fastq data using a find/replace.","t":"F","n":["main"],"q":[[0,"fasten_replace"]],"d":[""],"i":[0],"f":[[[]]],"c":[],"p":[]},\
"fasten_sample":{"doc":"downsample your reads","t":"FF","n":["main","rand_32"],"q":[[0,"fasten_sample"]],"d":["","Generate a set of random floats"],"i":[0,0],"f":[[[]],[[],[[2,[1]]]]],"c":[],"p":[[15,"f32"],[3,"Vec"]]},\
"fasten_shuffle":{"doc":"Interleaves reads from either stdin or file parameters.","t":"FFFF","n":["deshuffle","main","read_seqs","shuffle"],"q":[[0,"fasten_shuffle"]],"d":["Read from stdin and deshuffle reads into files","","Read fastq entries from a filename","Read fastq from stdin and interleave"],"i":[0,0,0,0],"f":[[1],[[]],[2,[[4,[3]]]],[1]],"c":[],"p":[[3,"Matches"],[3,"String"],[3,"Seq"],[3,"Vec"]]},\
"fasten_sort":{"doc":"Sort a fastq file. If the reads are paired end, then the …","t":"DLLLLLLMMLFMMMMMFLLLL","n":["Seq","borrow","borrow_mut","clone","clone_into","fmt","from","id1","id2","into","main","pe","qual1","qual2","seq1","seq2","sort_entries","to_owned","try_from","try_into","type_id"],"q":[[0,"fasten_sort"]],"d":["A sequence struct that is paired-end aware","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","","","","","","Sort fastq entries in a vector","","","",""],"i":[0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1],"f":[0,[[]],[[]],[1,1],[[]],[[1,2],3],[[]],0,0,[[]],[[]],0,0,0,0,0,[[[4,[1]],5,6],[[4,[1]]]],[[]],[[],7],[[],7],[[],8]],"c":[],"p":[[3,"Seq"],[3,"Formatter"],[6,"Result"],[3,"Vec"],[15,"str"],[15,"bool"],[4,"Result"],[3,"TypeId"]]},\
"fasten_straighten":{"doc":"Convert a fastq file to a standard 4-lines-per-entry format","t":"F","n":["main"],"q":[[0,"fasten_straighten"]],"d":[""],"i":[0],"f":[[[]]],"c":[],"p":[]},\
"fasten_trim":{"doc":"Blunt-end trims using 0-based coordinates","t":"FF","n":["main","trim_worker"],"q":[[0,"fasten_trim"]],"d":["","Trim a set of fastq entries and send it to a channel"],"i":[0,0],"f":[[[]],[[1,2,2],3]],"c":[],"p":[[3,"Seq"],[15,"usize"],[3,"String"]]},\
"fasten_validate":{"doc":"Validates your reads and makes you feel good about …","t":"F","n":["main"],"q":[[0,"fasten_validate"]],"d":[""],"i":[0],"f":[[[]]],"c":[],"p":[]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
